<script context='module'>
  RED.events.on('registry:module-updated', function(updatedModule) {
    if (updatedModule.module === 'openApi-red' && updatedModule.version === '2.0.0') {
      RED.nodes.eachNode(node => {
        if (node.type === 'openApi-red') {
          RED.editor.validateNode(node)
          RED.view.redraw()
        }
      })
      
      let updateNotification = RED.notify('Important notice: Updated openApi-red to version 2.0.0.<br\><br\>If an node error occurs at your openApi nodes on the workspace, deploy the update changes and reload the workspace, as this is usually a timing problem with the new config node.<br\>The nodes should work now as intended, <b>it is still highly recommended to check each node before using it.</b>', 
        { type: 'info', 
          fixed: true, 
          buttons: [{
            text: "Understood",
            class:"primary",
            click: function() { updateNotification.close() }
        }]
      })
    }
  })

  RED.nodes.registerType('openApi-red', {
    category: 'network',
    color: '#b197ff',
    defaults: {
      name: 			    { value: '', label: 'Name', placeholder: 'openApi-red', icon: 'tag' },
      configUrlNode:  { value: '', type: 'openApi-red-url', required: true },
      apiTag:         { value: '', label: 'API tag', required: true },
      keepAuth:       { value: false, label: 'Keep authentification', icon: 'lock' },
      operationData:  { value: {} , validate: function (v) { return v.id !== '' }},
      outputStyle:    { value: 'each response', label: 'Node output style'},
      errorHandling:  { value: 'throw exception', label: 'Error handling' },
      internalErrors: { value: {}, validate: function (v) { return !Object.values(v).find(error => error) }},
      parameters:     { value: {},  label: 'Parameters', validate: function(parameters) {
        if (!parameters || !Array.isArray(parameters) || parameters.length === 0 ) {
          return true
        } else {
          // if a required parameter has no value -> return false
          return !parameters.find(p => p.required && p.value === '')
        }
      }},
      requestContentType: { value: '',  label: 'Request Content Type' },
      responseContentType: { value: '',  label: 'Response Content Type' },
      outputs: {value: 1 },
      responseOutputLabels: { value: [{ 'code': 'default', 'text': 'default'}] },
      responseAsPayload: { value: false, label: 'Legacy mode', icon: 'file-code-o' },
      debugMode: { value: false, label: 'Debug mode', icon: 'bug'},
      headers: { value: [],  label: 'Custom Header' },
      _version: { value: '' }
    },
    inputs:1,
    outputs:1,
    outputLabels: function(index) {
      let label = this.responseOutputLabels[index]
      if (Number(label.code)) {
        return label.code + ': ' + label.text
      }
      return label.text
    },
    icon: 'white-globe.png',
    label: function() {
      return this.name || this.operationData?.title || this.operationData?.id || 'openApi client'
    },
    oneditprepare: function() {
      render(this, { minWidth: '600px' } )
    },
    oneditsave: function() {
      // remove unnecessary data 
      // TODO: check if inactive elements can be completly removed if no changed sub parameters exist
      const clone = this.__clone
      const cleanupParameter = (param) => {
        if (!param.required) {
          delete param.required
        } else {
          param.isActive = true // this should already be the case if required, but better safe than sorry
        }
        if (!param.isActive) delete param.isActive
        if (param.collapsed) delete param.collapsed
        if (!param.required && !param.isActive) {
          // inactiv -> remove unneccessary data
          // check if parameter has (active) sub parameter
          if (param.value === param.msgPathString) {
            delete param.value
            if (param.type === 'msg') delete param.type
          }
        }

        if (param.type?.startsWith('editor')) {
          // value is useless for editor mode
          delete param.value
        } else {
          // parameters object is only useful for editor mode
          delete param.parameters
        }

        if (param.type === 'each' && param.value.length) {
          // each mode only needs first value, if it was an array before with multiple values, we delete the rest
          param.value = [param.value[0]]
        }

        // definitiv garbage
        delete param.msgPathString
        const subParams = Object.keys(param.parameters || {})
        subParams.forEach(subParam => cleanupParameter(param.parameters[subParam]))
      }
      Object.keys(clone.parameters || {}).forEach(parameter => cleanupParameter(clone.parameters[parameter]))

      update(this)
    },
    oneditcancel: function() {
      revert(this)
    },
    onadd: function () { 
      addCurrentNodeVersion(this) 
    }
  })
</script>
 
<script>
  export let node
  import { Callout, Input, TabbedPane, TabContent } from 'svelte-integration-red/components'
  import NodeSettings from './components/NodeSettings.svelte'
  import CustomHeader from './components/CustomHeader.svelte'
  import RequestSettings from './components/RequestSettings.svelte'
  import Parameters from './components/Parameters.svelte'
  import specStore from './utils/specStore'
  import operationStore from './utils/operationStore.js'
  import { clearError, setError } from './utils/htmlFunctions'

  // temp variables
  node.currentUrl = RED.nodes.node(node.configUrlNode)?.url || ''

  const nodeSettingsCollapsed = !!node.configUrlNode
  // if only one setting exists -> set this config node automatically
  if (!node.configUrlNode) {
    let configNodes = []

    RED.nodes.eachConfig(cN => {
      if (cN.type === 'openApi-red-url') {
        configNodes.push(cN)
      }
    })
    if (configNodes.length === 1) {
      node.configUrlNode = configNodes[0].id
      node.currentUrl = configNodes[0].url
    }
  }

  $operationStore = {}
  clearError(node)

  // load specification into the store if not existing 
  if (node.configUrlNode && !$specStore[node.configUrlNode]) {
    specStore.loadOpenApiSpec(node.configUrlNode).catch(e => {
      setError(node, RED.utils.renderMarkdown(`Check console for detailed information. \n\n${e.message || e.text || JSON.stringify(e)}`), 'url')
      node.internalErrors = node.internalErrors // update UI
    })
  }

  let tabs = { "general": "General", "advanced": "Advanced" }

  $: if ($specStore[node.configUrlNode]) {
    clearError(node, 'url')
  }
</script>
 
<style>
 :global(#openApi-red-svelte-container :is(.required, .required label)) {
    font-weight: bold !important;
	}
  :global(#openApi-red-svelte-container .sir-Row label) {
    min-width: 182px;
  }
  :global(#openApi-red-svelte-container .sir-Row label i) {
    min-width: 14px;
  }
  :global(#openApi-red-svelte-container .overviewTextHeader) {
    width: 100%;
    text-overflow: ellipsis;
    overflow: hidden;
    text-wrap: nowrap;
    padding-right: 10px;
    color: var(--red-ui-secondary-text-color);
  }
</style>

{#if node.internalErrors.text}
  <Callout type="error">
    <span slot="header">Error</span>
    {@html node.internalErrors.text}
  </Callout>
{/if}
<TabbedPane bind:tabs>
  <TabContent tab="general">
    <NodeSettings bind:node collapsed={nodeSettingsCollapsed}/>
    {#if node.configUrlNode && node.configUrlNode !== '_ADD_' && (!node.currentUrl || !$specStore[node.configUrlNode])}
      <div style="font-size: larger;">
        Loading... <i class="fa fa-spinner fa-pulse" style="margin-left: 6px;"></i>
      </div>
    {:else if $specStore[node.configUrlNode] && node.currentUrl}
      <RequestSettings bind:node/>
      <Parameters bind:node/>
    {/if}
  </TabContent>
  <TabContent tab="advanced">
    <Input bind:node prop="keepAuth" labelBeforeCheckbox={true} tooltip={`⚠️ Use with caution as it will reveal sensible data to the flow!\n\nmsg.openApiToken and msg.headers will not be deleted and can be seen by other nodes in the flow.`}/>
    <Input bind:node prop="debugMode" labelBeforeCheckbox={true} tooltip={`⚠️ Use with caution as this may reveal sensible data to the flow!\n\n Put the whole sending data into msg.openApiDebugData and the debug console.`}/>
    <Input bind:node prop="responseAsPayload" labelBeforeCheckbox={true} tooltip="Legacy mode: Put the whole response into the payload instead of only response.obj."/>

    <CustomHeader bind:node />
  </TabContent>
</TabbedPane>
<script>
  import { Button, Collapsible, EditableList, Input, Row, TypedInput } from 'svelte-integration-red/components'
  import ParameterTypeAttachment from './ParameterTypeAttachment.svelte';
  import { createParameters, createParameter, getTypedInputType, getAllowedTypes, getMultipleSchemesType } from '../utils/htmlFunctions'
  import { tick } from 'svelte'

  export let node, parameter, paramMetaData, apiOperationData, schema, additionalEachTypes

  const getArrayClazz = () => {
    let clazz = 'arrayList'
    if (parameter.type === 'each') clazz += ' each'
    if (arrayError && nestedParam.parentActive) clazz += ' arrayError'
    return clazz
  }

  // also in ParameterInput
  const editActiveParamFilter = (index) => {
    console.log('editActiveParamFilter', index)
    const value = (parameter.value[index]?.activeFilter) ? parameter.value[index].activeFilter :  '{\n\treturn true\n}'
    monaco.languages.typescript.javascriptDefaults.addExtraLib('const ' + ['value', ...additionalEachTypes.join(', ')], 'openapi_red')
    RED.editor.editJavaScript({
      value: value,
      title: 'Javascript Editor',
      width: 'Infinity',
      mode: 'ace/mode/nrjavascript',
      complete: (content) => {
        // Save the content (after UI exists again, tick is too short)
        setTimeout(() => {
          // check if anything was set
          if (content && content.trim() === '{\n\treturn true\n}') {
            parameter.value[index].activeFilter = ''
          } else {
            parameter.value[index].activeFilter = content
            delete monaco.languages.typescript.javascriptDefaults._extraLibs.openapi_red
          }
        }, 500)
      }
    })
  }

  const getArraySchemes = () => {
    return paramMetaData.items?.[arrayMultiSchemesType] || paramMetaData.schema?.[arrayMultiSchemesType] || paramMetaData.items || paramMetaData.schema || paramMetaData || {}
  }

  const getArrayElementSchema = (index) => {
    let arraySchema = {}    
    if (arrayMultiSchemesType) {
      arraySchema = Object.values(getArraySchemes()).find(thisSchema => thisSchema?.$$ref?.endsWith('/' + parameter.value[index].selectedSchema?.name)) || {}
    } else {
      arraySchema = getArraySchemes()
    }  
    return arraySchema
  }

  const addNewArrayElement = () => {
    const defaultType = arrayTypes[0]?.value || arrayTypes[0]
    const type = (defaultType.startsWith('editor')) ? defaultType : 'msg'
    const nextIndex = parameter.value.length
    // use first found
    const selectedArrayElementSchema = arrayMultiSchemesType
      ? getArraySchemes()?.[0] || {} 
      : getArraySchemes() || {}
    
    const newValue = createParameter(nextIndex.toString(), { type }, selectedArrayElementSchema, true, parameter.msgPathString, true)
    parameter.value.push(newValue)
    parameter.value = parameter.value
  }

  const walkThroughParameters = (param, callback) => {
    // param itself
    callback(param)
    // if param owns additional parameters
    Object.values(param.parameters).forEach(p => callback(p))
    // children parameters    
    if ((param.type === 'each' || param.type === 'array') && Array.isArray(param.value)) {
      param.value.forEach(childParam => walkThroughParameters(childParam, callback))
    }
  }

  const createAdditionalEachTypes = async (init = false) => {
    // blur event has no value -> use oldAsValue to check
    rebuild = true // using node = node or parameter = parameter didn't help
    if (!init && oldAsValue !== parameter.as) {
      const oldAsType = '_each_' + oldAsValue
      const newAsType = '_each_' + parameter.as
      additionalEachTypes = additionalEachTypes.filter(t => t !== oldAsValue)
      oldAsValue = parameter.as
      // update all sub parameters if they use the old "as" value
      walkThroughParameters(parameter, (p) => {
        if (p.type === oldAsType) {
          p.type = newAsType
        }
      })
    }
    if (parameter.as && !additionalEachTypes.includes(parameter.as)) {
      additionalEachTypes.push(parameter.as)
      additionalEachTypes = additionalEachTypes.sort()
    }
    await createArrayTypes()
    await repairValue(parameter.type)
    await tick()
    rebuild = false
  }

  const createArrayTypes = () => {
    // additionalEachTypes = additionalEachTypes || parameter.type === 'each'
    if (arrayMultiSchemesType) {
      const editorTypes = []
      const nonEditorTypes = []
      const arraySchemes = paramMetaData.items?.[arrayMultiSchemesType] ||  paramMetaData.schema?.items?.[arrayMultiSchemesType] || []
      arraySchemes.forEach((schema, index) => {
        const type = getTypedInputType(schema)
        if (type.startsWith('editor')) {
          // split editor value from rest
          const types = getAllowedTypes(schema, parameter.name + '_' + index, additionalEachTypes)
          editorTypes.push(types.shift())
          nonEditorTypes.push(...types)
        } else {
          nonEditorTypes.push(...getAllowedTypes(paramMetaData, parameter.name, additionalEachTypes))
        }
      })
      arrayTypes = [...editorTypes, ...new Set(nonEditorTypes)]
    } else {
      arrayTypes = getAllowedTypes(schema.items || paramMetaData.items || {}, parameter.name, additionalEachTypes)
    }
  }

  const getTypedInputClazz = (param) => {
    let clazz = ''
    if (param.type === 'msg' || param.type === 'flow' || param.type === 'global') clazz += 'externalValue'
    if (param?.type?.startsWith('editor')) clazz += ' arrayEditor'
    return clazz
  }

  // similar to parameterInput
  const handleTypeSelection = async (e, index) => {
    rebuild = true
    const type = e.detail.type
    if (typeof index !== 'undefined') {
      parameter.value[index].value = e.detail.value
      parameter.value[index].type = type
    }
    // repair array
    await repairValue(type)
    // handleTypeSelection mainly function from parameterRow
    if (type.startsWith('editor')) {
      const multiSchemeTypes = getMultipleSchemesType(paramMetaData) 
      // clear value from (main) parameter when switching to editor (parsing will be difficult to impossible, and user should see that those two are different...)
      if (multiSchemeTypes) {
        parameter.value[index].selectedSchema.name = type.substring(7)
        await createParameters(node, apiOperationData)
      }
      // must update parameter manually, as this parameter will not be updated while node.parameters[xxx] already exists.
      parameter = await createParameter(parameter.name, parameter, paramMetaData, parameter.required, parameter.msgPathString.slice(0, (parameter.name.length + 1) * -1 ))
    } else if (type === 'msg' && parameter.value === '') {
      parameter.value = parameter.msgPathString
    }
    if (type.startsWith('editor') || type === 'each' || type === 'array') {
      parameter.collapsed = false
    }
    await tick()
    rebuild = false
  }

  const repairValue = (type) => {
    const rebuildArray = (!Array.isArray(parameter.value) || !parameter.value.length || parameter.value.find(v => !v?.type) !== undefined)
    if ((type === 'each' || type === 'array' || typeof index !== 'undefined') && rebuildArray) {
      parameter.value = []
      if (type === 'each') {
        parameter.eachType ||= 'msg' // add eachType if not existing
      }
    }
    if (!parameter.value.length) {
      addNewArrayElement()
    }
  }

  const getButtonClazz = (param) => {
    let clazz = 'activeFilter'
    if (param.activeFilter) clazz +=  ' isActive'
    if (Object.keys(param.parameters || {}).length) clazz += ' intendedYieldFilter'
    return clazz
  }

  const arrayMultiSchemesType = getMultipleSchemesType(paramMetaData, true)
  let arrayTypes = []
  let arrayError = false
  let rebuild = false
  let oldAsValue = parameter.as

  // creates array and additional each typedInput types
  createAdditionalEachTypes(true)

  $: if (parameter.as !== oldAsValue) {
    createAdditionalEachTypes()
  }

  $: if (parameter.type === 'array' && parameter.value) {
    const minValueOk = (!paramMetaData.minItems || parameter.value.length >= paramMetaData.minItems)
    const maxValueOk = (!paramMetaData.maxItems || parameter.value.length < paramMetaData.maxItems)
    const uniqueOk = (!paramMetaData.uniqueItems || new Set(parameter.value).size === parameter.value.length)
    arrayError = !(minValueOk && maxValueOk && uniqueOk)
  } else {
    arrayError = false
  }
</script>

<style>
  :global(#openApi-red-svelte-container .parametersList .sir-Collapsible.arrayParameterCollapsible > .sir-Collapsible-content.sir-Collapsible-indented) {
    padding-left: 20px;
  }
  :global(#openApi-red-svelte-container .sir-Row:is(.indentedEachAsInput, .yield) label) {
    min-width: 260px;
  }
  /* within a typed input we still need full width */
  :global(#openApi-red-svelte-container .sir-Row.indentedEachAsInput .sir-TypedInput input) {
    width: 100%;
  }
  :global(#openApi-red-svelte-container .sir-Row.indentedEachAsInput :is(.sir-TypedInput, input)) {
    width: calc(100% - 250px)
  }
  /* hide additional values from "old" array if each was selected */
  :global(#openApi-red-svelte-container .arrayList) {
    margin-left: 270px;
  }
  /* change type "each" css to avoid changing logic to array */
  :global(#openApi-red-svelte-container .arrayList.each) {
    margin-left: 42px;
    flex-direction: row;
  }
  :global(#openApi-red-svelte-container .arrayList.each > .sir-ComponentHeader) {
    width: 200px;
  }
  /* set collapsible into line of array type selection */
  :global(#openApi-red-svelte-container .arrayParameterCollapsible > .sir-ComponentHeader) {
    margin-top: -46px;
    height: 34px;
    margin-bottom: 6px !important;
  }
  :global(#openApi-red-svelte-container .arrayParameterCollapsible > .sir-ComponentHeader > .sir-ComponentHeader-content) {
    padding-left: 20px;
  }
  :global(#openApi-red-svelte-container .intendedYieldFilter.activeFilter) {
    margin-left: 20px;
    z-index: 99;
  }
  :global(#openApi-red-svelte-container .arrayEditor) {
    margin-left: 220px;
    /* width: calc(100% - 258px); */
  }
  /* error */
  :global(#openApi-red-svelte-container .arrayError .red-ui-editableList-container) {
    border-color: var(--red-ui-border-color-error);
  }
  :global(#openApi-red-svelte-container .eachYield label) {
    min-width: 232px;
  }
</style>

<!-- TODO check if each and array can be combined somehow (another component or bind on "editableList" => simple div with slot or list) -->
{#if parameter.type === 'each'}
  <TypedInput label="Iterate" bind:type={parameter.eachType} bind:value={parameter.each} types={["msg", "flow", "global", "json"]} maximize={false} clazz="indentedEachAsInput" />
  <Input label="As" bind:value={parameter.as} on:blur={createAdditionalEachTypes} maximize={false} clazz="indentedEachAsInput"/>
  {#if !rebuild && parameter.value?.[0]?.type}
    <Row clazz="eachYield">
      <Button small inline icon="filter" clazz={getButtonClazz(parameter.value[0])} tooltip={'return a boolean value.\n\nUse msg, the current "each "as" name" or value for the current value.\n\n' + parameter.value[0].activeFilter || '{ return true '} on:click={() => editActiveParamFilter(0)} />  
      <TypedInput inline label={parameter.value[0].type.startsWith('editor') && Object.keys(getArrayElementSchema(0)?.properties || {})?.length ? false : "Yield"} 
        type={parameter.value[0].type} value={parameter.value[0].value} types={arrayTypes} 
        clazz={getTypedInputClazz(parameter.value[0], true) + ' yield'} on:blur={(e) => handleTypeSelection(e, 0)} placeholder={'The whole entry value.'}
      />
    </Row>   
    <!-- each editor (collapsible) or input field -->
    {#if parameter.value[0].type.startsWith('editor') && Object.keys(getArrayElementSchema(0)?.properties || {})?.length}
      <Collapsible label="Yield" clazz="arrayParameterCollapsible">
        <ParameterTypeAttachment bind:node bind:parameter={parameter.value[0]} paramMetaData={getArrayElementSchema(0)} {apiOperationData} inArrayValue {additionalEachTypes}/>
      </Collapsible>
    {:else}
      <ParameterTypeAttachment bind:node bind:parameter={parameter.value[0]} paramMetaData={getArrayElementSchema(0)} {apiOperationData} inArrayValue {additionalEachTypes}/>
    {/if}
  {/if}
{:else if parameter.type ==='array'}
  <EditableList sortable removable addButton minHeight="0px" maxHeight=900 clazz={getArrayClazz(parameter.type)}
    bind:elements={parameter.value} let:element={el} let:index
    on:add={addNewArrayElement}
  >
    {#if !rebuild}
      <Row>
        <Button small inline icon="filter" clazz={getButtonClazz(parameter.value[0])} tooltip={'return a boolean value.\n\nUse msg, the current "each "as" name" or value for the current value.\n\n' + parameter.value[index].activeFilter || '{ return true '} on:click={() => editActiveParamFilter(index)} />
        <TypedInput inline type={el.type} value={el.value} types={arrayTypes} clazz={getTypedInputClazz(el, true)} on:blur={(e) => handleTypeSelection(e, index)}/>
      </Row>
      {#if Object.keys(getArrayElementSchema(index)?.properties || {})?.length}
        <Collapsible label={el.type.startsWith("editor") ? "Yield" : " " } clazz="arrayParameterCollapsible">
          <ParameterTypeAttachment bind:node bind:parameter={parameter.value[index]} paramMetaData={getArrayElementSchema(index)} {apiOperationData} inArrayValue {additionalEachTypes}/>
        </Collapsible>
      {/if}
    {/if}
  </EditableList>
{/if}
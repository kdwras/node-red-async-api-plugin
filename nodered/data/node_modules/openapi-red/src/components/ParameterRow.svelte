<script>
  import { Callout, Collapsible } from 'svelte-integration-red/components'
  import ParameterTypeAttachment from './ParameterTypeAttachment.svelte'
  import ParameterInput from './ParameterInput.svelte'
  import ArrayTypeInput from './ArrayTypeInput.svelte'
  import { getMultiSelectionSelectedSchema, getTypedInputType, getAllowedTypes, getMultipleSchemesType } from '../utils/htmlFunctions'
  
  // referencing to an unknown/no longer available schema or other errors in the spec can lead to trying create an parameter which does not exist and would crash the node
  export let node, apiOperationData, parameter = { type: 'unknown', value: '' }, paramMetaData = {}, nestedParam = {}, firstLevel = false, additionalEachTypes = []

  const getParameterRowClazz = () => {
    let clazz = 'parameterRow'
    if (parameter.type === 'array' || parameter.type === 'each') {
      clazz += ' arrayParameterParent'
    }
    return clazz
  }

  const setAllowedValue = () => {
    // default string (all values except...)
    if (typeof parameter.value === 'string' && parameter.value.startsWith('payload')) {
      parameter.type = 'msg'
    // ...an Array allowed by the editor
    } else {
      parameter.type = allowedTypes[0]?.value || allowedTypes[0]
      if (parameter.type === 'array' && !Array.isArray(parameter.value)) {
        parameter.value = []
      } else {
        parameter.value = ''
      }
    }
  }

  const multiSchemesType = getMultipleSchemesType(paramMetaData)
  let allowedTypes = []
  let schema = paramMetaData.schema || {} // if multiSchemeTypes -> set to specific schema after getting types and check if editor still exists
 
  if (multiSchemesType) {
    const editorTypes = []
    const nonEditorTypes = []
    const multiSchemesList = paramMetaData.schema?.[multiSchemesType] || paramMetaData[multiSchemesType]
    
    multiSchemesList.forEach((schema, index) => {
      const type = getTypedInputType(schema)
      if (type.startsWith('editor')) {
        // split editor value from rest
        const types = getAllowedTypes(schema, parameter.name + '_' + index, additionalEachTypes)
        editorTypes.push(types.shift())
        nonEditorTypes.push(...types)
      } else {
        nonEditorTypes.push(...getAllowedTypes(schema, null, additionalEachTypes))
      }
    })
    allowedTypes = [...editorTypes, ...new Set(nonEditorTypes)]
  } else {
    allowedTypes = getAllowedTypes(paramMetaData, parameter.name, additionalEachTypes) 
  }
  
  if (!allowedTypes.find(type => (type?.value || type) === parameter.type)) {
  // parameter was identified as an editor object, but 
    // -> a) didn't had any further data collected in Parameters.svelte --> this happens on creating parameter at the first time
    // -> b) if an editor was selected and api/operation was changed, this editor may not be available anymore -> select the first existing
    if (parameter.type.startsWith('editor')) {
      const firstEditorType = allowedTypes.find(type => type?.value?.startsWith('editor'))
      if (firstEditorType) {
        parameter.type = firstEditorType.value
        parameter.selectedSchema =  {
          name: firstEditorType.value.substring(7),
          type: multiSchemesType
        }
      } else {
        setAllowedValue()
      }
    } else {
      // parameter type has changed (other api operation or it was changed in the spec) and couldn't be found -> select first allowed
      setAllowedValue()
    }
  }
  // if multiSelection -> get specific schema
  if (multiSchemesType) {
    schema = getMultiSelectionSelectedSchema(parameter, paramMetaData)
  }
 
  let description = paramMetaData.description || paramMetaData.summary || ''
  if (paramMetaData.deprecated) {
    description = '*WARNING: DEPRECEATED*\n\n' + description
  }
  if (paramMetaData.default) {
    description += '\n\nDefault value: ' + paramMetaData.default
  }
  if (paramMetaData.example) {
    description += '\n\nExample: ' + paramMetaData.example
  }
  if (paramMetaData.examples) {
    description += '\n\nExamples' + JSON.stringify(paramMetaData.examples)
  }
  if (firstLevel && parameter.type.startsWith('editor')) {
    parameter.collapsed = false
  }
</script>

<style>
  :global(#openApi-red-svelte-container .parameterRow) {
    overflow: visible;
  }
  /* collapsible sub row */
  :global(#openApi-red-svelte-container .parameterRow .parameterRow.sir-Collapsible > .sir-ComponentHeader) {
    margin-left: -22px;
    width: calc(100% + 22px);
  }
  :global(#openApi-red-svelte-container .parameterRow .fa.fa-angle-right.sir-ComponentHeader-icon) {
    margin-right: 8px;
    margin-left: 8px;
  }
  :global(#openApi-red-svelte-container .parameterRow .sir-ComponentHeader) {
    margin-right: 0px !important;
  }
  :global(#openApi-red-svelte-container .parameterRow > .sir-Collapsible-content) {
    margin-top: 12px;
  }
  .maximize {
    width: 100%
  }
</style>
{#if parameter && parameter.type && parameter.type !== 'unknown'}
  {#if Object.keys(paramMetaData.properties || schema.properties || {}).length || parameter.type === 'array' || parameter.type === 'each'}
    <!-- JSON object (Editor UI) -->
    <Collapsible clazz={getParameterRowClazz()} bind:collapsed={parameter.collapsed} openOnlyOnIcon>
      <span slot="header" class="maximize">
        <ParameterInput bind:node collapsible bind:parameter bind:nestedParam bind:schema bind:additionalEachTypes {paramMetaData} {apiOperationData} {description} {allowedTypes} {multiSchemesType}/>
        {#if node.showCalloutBox && description}
          <Callout type="info" small>{description}</Callout>
        {/if}
      </span>
      {#if parameter.type === 'array' || parameter.type === 'each'}
        <ArrayTypeInput bind:node bind:parameter {paramMetaData} {schema} {apiOperationData} {additionalEachTypes}/>
      {:else}
        <ParameterTypeAttachment bind:node bind:parameter {paramMetaData} {schema} {apiOperationData} {multiSchemesType}/>
      {/if}      
    </Collapsible>
  {:else}
    <ParameterInput bind:node bind:parameter bind:nestedParam bind:schema bind:additionalEachTypes {paramMetaData} {apiOperationData} {description} {allowedTypes} {multiSchemesType}/>
    {#if node.showCalloutBox && description}
      <Callout type="info" small>{description}</Callout>
    {/if}
    <ParameterTypeAttachment bind:node bind:parameter {paramMetaData} {schema} {apiOperationData} {multiSchemesType}/>
  {/if}
{:else}
  <Callout type="error" small>Unknown parameter{#if parameter?.name}: {parameter.name}{/if}</Callout>
{/if}
<script>
  export let node
  import { Button, Callout, Collapsible, Row, Select } from 'svelte-integration-red/components'
  import { clearError, createOutputs, setError } from '../utils/htmlFunctions'
  import specStore from '../utils/specStore.js'
  import operationStore from '../utils/operationStore'

  const initContentType = (type) => {
    if (!contentTypes[type].length) {
      node[type + 'ContentType'] = ''
    } else if (!contentTypes[type].includes(node[type + 'ContentType'])) {
      // set default application/json, if available, else first match...
      node[type + 'ContentType'] = contentTypes[type].includes('application/json') ? 'application/json' : contentTypes[type][0]
    }
  }

  const getApiTooltip = () => {
    const tagDescription = $specStore[node.configUrlNode]?.tags?.find(tag => tag.name === node.apiTag)?.description || ''
    // const pathDescription = 
    apiTooltip = RED.utils.sanitize(tagDescription)
  }

  const contentTypes = {
    request: [],
    response: []
  }
  let collapsed = node.apiTag && node.operationData.id
  let apiTooltip = ''
  let operationTooltip = ''
  let oldOperationId = ''
  let apis = []
  let operations = []

  getApiTooltip()
  // reactive creating contentTypes (request and response type)
  $: if ($specStore[node.configUrlNode]?.paths?.[node.operationData.path]?.['x-openApi-red-resolved'] && (node.recreateRequestSettings || node.operationData.id !== oldOperationId)) {
    delete node.recreateRequestSettings
    oldOperationId = node.operationData.id
    node.operationData = $operationStore[node.apiTag]?.find(op => op.id === node.operationData.id) || {}
    const paths = $specStore[node.configUrlNode]?.paths?.[node.operationData.path]
    const methods = Object.keys(paths || {})
    const method = methods.find((method) => {
      const opData = paths[method]
      if (opData.operationId) {
        return opData?.operationId === node.operationData.id
      } else {
        return (method + node.operationData.path) === node.operationData.id
      }
    })
    const apiOperationData = paths?.[method]
    if (!apiOperationData) {
      setError(node, 'Error getting operationData for "' +  node.operationData.id + '".', 'getOperationData')
    } else {
      clearError(node, 'getOperationData')
      // if path has a general description add it to the selected operation
      const pathDescription = $specStore[node.configUrlNode].paths?.[node.operationData.path]?.description 
        ? $specStore[node.configUrlNode].paths?.[node.operationData.path]?.description + '\n\n'
        : ''
      operationTooltip = RED.utils.sanitize(pathDescription + (apiOperationData.description || apiOperationData.summary || ''))
      // set valid content Types if operation is set
      // needed input since an update from swagger.js
      contentTypes.request = ['application/json', 'application/x-www-form-urlencoded', 'multipart/form-data'] // some default types as fallback
      if (Object.keys(apiOperationData.requestBody?.content || {}).length) {
        contentTypes.request = Object.keys(apiOperationData.requestBody.content)
      } else if (apiOperationData.consumes) { // swagger style
        contentTypes.request = apiOperationData.consumes
      }

      initContentType('request')
      let responseContentTypes = []
      // responses exists in swagger and openApi but in swagger the response data type is stated in "produces"
      if (apiOperationData?.produces) {
        responseContentTypes = apiOperationData.produces // swagger style
      }
      if (apiOperationData?.responses) {
        Object.values(apiOperationData.responses).forEach(response => {
          if (response?.content) {
            Object.keys(response.content)?.forEach(cT => responseContentTypes.push(cT))
          }
        })
      }
      // distinct array
      contentTypes.response = Array.from(new Set(responseContentTypes))
      initContentType('response')
    }
  }

  $: if (!node.apiTag || !node.operationData?.id) {
    contentTypes.request = []
    contentTypes.response = []
    node.operationData.id = ''
    collapsed = false
  }
  
  $: {
    apis = Object.keys($operationStore || {})
    operations = $operationStore[node.apiTag] || []
  }
  // $: apiTooltip = getTooltip($specStore[node.configUrlNode]?.tags, node.apiTag)
</script>


<Collapsible label="Request settings" id="openApiRequestSetting" icon="level-up" bind:collapsed border>
  <span slot="header" class:overviewTextHeader={collapsed} class:header={!collapsed}>
    {#if collapsed}
      Api: {node.apiTag || "No api selected"} | Operation: {node.operationData?.title || node.operationData?.id || "No operation selected"}
    {:else if (operationTooltip || apiTooltip)}
      <Button inline  small label={node.showCalloutBox ? "hide description" : "show description"} icon={node.showCalloutBox ? "eye-slash" : "eye"}  on:click={() => node.showCalloutBox = !node.showCalloutBox}/>
    {/if}
  </span>
  <Select bind:node prop="apiTag" icon="tag" error={!node.apiTag} 
    on:change={() => {
      node.operationData = {}
      getApiTooltip()
    }}
    tooltip={node.showCalloutBox ? '' : apiTooltip}
  >
    <option value="">Please select the api.</option>
    { #each apis as api (api)}
      <option value={api} selected={node.apiTag === api}>{api}</option>
    {/each}
  </Select>
  <Callout type="info" bind:show={node.showCalloutBox}>
    {@html apiTooltip}
  </Callout>

  <Row>
    <Select inline label="Operation" icon="wrench" error={!node.operationData.id} value={node.operationData.id} tooltip={node.showCalloutBox ? '' : operationTooltip} 
      on:change={(e) => {
        // option value cannot be an object
        node.operationData = $operationStore[node.apiTag]?.find(operation => operation.id === e.detail.value) || {}
        createOutputs(node, $specStore)
        clearError(node, 'getOperationData')
      }} 
    >
      <option value="">Please select an operation.</option>
      {#each operations as operation (operation)}
        <!-- a path can have multiple operations, but also additional data like description or parameter for all operations /paths/myPath/{myParamteter} -->
        {#if operation?.id}
          <option selected={node.operationData.id === operation.id} value={operation.id}>{operation.title || operation.id}</option>
        {/if}
      {/each}
    </Select>
  </Row>
  <Callout type="info" bind:show={node.showCalloutBox}>
    {@html operationTooltip}
  </Callout>
  {#if contentTypes.request.length}
    <Select bind:node prop="requestContentType" icon="file-in.svg">
      {#each contentTypes.request as reqCT}
        <option value={reqCT} selected={node.requestContentType === reqCT}>{reqCT}</option>
      {/each}
    </Select>
  {/if}
  {#if contentTypes.response.length}
    <Select bind:node prop="responseContentType" icon="file-out.svg">
      {#each contentTypes.response as resCT}
        <option value={resCT} selected={node.responseContentType === resCT}>{resCT}</option>
      {/each}
    </Select>
  {/if}
</Collapsible>

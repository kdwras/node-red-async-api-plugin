<script>
  import { Button, Row, Input, TypedInput, Tooltip } from "svelte-integration-red/components"
  import { createParameters, createParameter, getMultiSelectionSelectedSchema, getTypedInputType, getMultipleSchemesType } from '../utils/htmlFunctions'

  export let node, collapsible, parameter, paramMetaData, apiOperationData, schema, nestedParam, description, allowedTypes, additionalEachTypes = []

  const toggleCollapsed = () => parameter.collapsed = !parameter.collapsed

  // also in ArrayTypedInput
  const editActiveParamFilter = () => {
    const value = (parameter?.activeFilter) ? parameter.activeFilter :  '{\n\treturn true\n}'
    monaco.languages.typescript.javascriptDefaults.addExtraLib('const ' + ['value', ...additionalEachTypes.join(', ')], 'openapi_red')
    RED.editor.editJavaScript({
      value: value,
      title: 'Javascript Editor',
      width: 'Infinity',
      mode: 'ace/mode/nrjavascript',
      complete: (content) => {
        // Save the content (after UI exists again, tick is too short)
        setTimeout(() => {
          // check if anything was set
          if (content && content.trim() === '{\n\treturn true\n}') {
            parameter.activeFilter = ''
          } else {
            parameter.activeFilter = content
            delete monaco.languages.typescript.javascriptDefaults._extraLibs.openapi_red
          }
        }, 500)
      }
    })
  }

  const handleTypeSelection = (e, index) => {
    let isArray = false
    const type = e.detail.type
    const rebuildArray = (!Array.isArray(parameter.value) || parameter.value.find(v => !v?.type) !== undefined)
    if ((type === 'each' || type === 'array' || typeof index !== 'undefined') && rebuildArray) {
      parameter.value = []
      // addNewArrayElement()
      if (type === 'each') {
        parameter.eachType ||= 'msg' // add eachType if not existing
      }
    }
    if (parameter.type !== 'each' && parameter.as) {
      // remove eachAs from additionalEachTypes
      additionalEachTypes = additionalEachTypes.filter(v => v !== parameter.as)
    }
    if (typeof index !== 'undefined') {
      isArray = true
      parameter.value[index].value = e.detail.value
      parameter.value[index].type = type
    }
    // handleTypeSelection mainly function from parameterRow
    if (type.startsWith('editor')) {
      const multiSchemeTypes = getMultipleSchemesType(paramMetaData, isArray) 
      // clear value from (main) parameter when switching to editor (parsing will be difficult to impossible, and user should see that those two are different...)
      if (multiSchemeTypes) {
        if (isArray) {
          parameter.value[index].selectedSchema.name = type.substring(7)
        } else {
          parameter.selectedSchema.name = type.substring(7)
          schema = getMultiSelectionSelectedSchema(parameter, paramMetaData)
        }
        createParameters(node, apiOperationData)
        // must update parameter manually, as this parameter will not be updated while node.parameters[xxx] already is.
        parameter = createParameter(parameter.name, parameter, paramMetaData, parameter.required, parameter.msgPathString.slice(0, (parameter.name.length + 1) * -1 ))
        parameter.collapsed = false
      }
    } else if (type === 'msg' && parameter.value === '') {
      parameter.value = parameter.msgPathString
    }
  }

  // getIcon gets the icon that represents the data type from the parameter, not the selection
  const getIcon = () => {
    const multiSchemesType = (getMultipleSchemesType(paramMetaData))
    const schema = paramMetaData.schema?.[multiSchemesType]?.[0] || paramMetaData[multiSchemesType]?.[0] || paramMetaData.schema
    let defaultType = schema?.type || paramMetaData.type
    // mixed types allowed -> use first one
    if (defaultType?.oneOf) {
      defaultType = defaultType.oneOf[0]
    }
    // allowed data types 
    // https://swagger.io/docs/specification/data-models/data-types/
    switch (defaultType) {
      case 'number':
      case 'integer':
        return 'red/images/typedInput/09.svg'
      case 'boolean':
        return 'red/images/typedInput/bool.svg'
      case 'object':
        return 'red/images/typedInput/json.svg'
      case 'array':
        return 'list-ol'
      default:
        return 'red/images/typedInput/az.svg'
    }
  }


  const getTypedInputClazz = (param, isArray) => {
    let clazz = ''
    if (param.type === 'msg' || param.type === 'flow' || param.type === 'global') clazz += 'externalValue'
    if (isArray && param?.type?.startsWith('editor')) clazz += ' arrayEditor'
    return clazz
  }

  const defaultTypedInputType = getTypedInputType(paramMetaData)
  const labelId = parameter.name + '_' + parameter.type + '_' + Date.now()
  const icon = getIcon()
  const required = parameter.required
  let placeholder = paramMetaData.default || schema.default || ''

  if (typeof placeholder === 'object') {
    try {
      placeholder = JSON.stringify(placeholder)
    } catch (e) {
      placeholder = 'Invalid Json placeholder / default value'
    }
  }

  if (defaultTypedInputType === 'array') {
    if (paramMetaData.minItems) description += '\n\n⚠️ Minimum items: ' + paramMetaData.minItems
    if (paramMetaData.maxItems) description += '\n\n⚠️ Maximum items: ' + paramMetaData.maxItems
    if (paramMetaData.uniqueItems) description += '\n\n⚠️ Items must be unique!'
  }
</script>

<style>
  .pointer {
    cursor: pointer;
  }
  .maximize {
    width: 100%
  }

  :global(#openApi-red-svelte-container .onlyCheckbox) {
    min-width: 17px;
    width: 17px;
  }
  /* push the label of the checkbox to the left to show filter button */
  :global(#openApi-red-svelte-container .onlyCheckbox:not(.required) label.sir-Label) {
    padding-left: 25px;
  }
  /* only for icon after checkbox */
  :global(#openApi-red-svelte-container .parameterRow label.sir-Label) {
    pointer-events: none;
  }
  /* set min width for font-awesome icons */
  :global(#openApi-red-svelte-container .parameterRow .sir-Row label i) {
    min-width: 27px;
  }
  /* align parameters to top and use margin to lower the label */
  :global(#openApi-red-svelte-container .parameterInput) {
    align-items: flex-start;
  }

  /* the real label */
  .parameterLabelOuter {
    display: inline-flex;
    align-items: center;
    min-height: 34px;
  }
  :global(#openApi-red-svelte-container .param-label) {
    min-width: 200px;
    width: 200px;
    overflow-wrap: break-word;
    padding-left: 28px;
  }
  :global(#openApi-red-svelte-container .param-label.required) {
    min-width: 220px;
  }
  :global(#openApi-red-svelte-container .sir-Input-container .checkbox) {
      display: inline-flex;
  }
  :global(#openApi-red-svelte-container .sir-Input-container .checkbox input) {
    margin-top: 0px;
  }
  /* typedInput label marker if value is from extern */
  :global(.sir-TypedInput-container.externalValue:focus-within button.sir-TypedInput-options-button .sir-TypedInput-ui-type-label) {
    color: var(--red-ui-border-color-warning);
  }
  /* filter button style */
  :global(#openApi-red-svelte-container .activeFilter.isActive i) {
    color: var(--red-ui-primary-text-color)
  }
  :global(#openApi-red-svelte-container .activeFilter i) {
    color: var(--red-ui-workspace-button-color-disabled);
  }
  :global(#openApi-red-svelte-container .activeFilter button) {
    border-color: transparent;
  }
</style>

<Row clazz={"parameterInput" + (collapsible ? "": " notCollapsible")}>
  <!-- empty label to show icon -->
  <div class="parameterLabelOuter">
    <Input inline type="checkbox" label=" " bind:value={parameter.isActive} disabled={required || nestedParam.parentActive === false} {icon} clazz={"onlyCheckbox" + (required ? ' required' : '')}
      on:click={() => {
        setTimeout(() => {
          // update activation may not trigger the children in editor mode (in some cases (requestBody)
          node = node
          if (parameter.isActive && parameter.type.startsWith('editor')) {
            parameter.collapsed = false
          } else if (!parameter.isActive) {
            parameter.collapsed = true
          }
        }, 50)
      }}
    />
    {#if !parameter.required}
      <Button small inline icon="filter" clazz={"activeFilter" + (parameter.activeFilter ? ' isActive' : '')} tooltip={'return a boolean value.\n\nUse msg, the current "each "as" name" or value for the current value.\n\n' + parameter.activeFilter || '{ return true '} disabled={parameter.required} on:click={editActiveParamFilter} />
    {/if}
    <!-- svelte-ignore a11y-no-static-element-interactions -->
    <div id={labelId} class="param-label" class:required class:pointer={collapsible} on:click={toggleCollapsed} on:keydown={toggleCollapsed}>
      {nestedParam.name||parameter.name}{required ? '*' : ''}
      {#if !node.showCalloutBox && description} 
        <i class="fa fa-info-circle pointer" id={labelId + "_sir-Tooltip-icon"}></i>
        <Tooltip id={labelId} tooltip={node.showCalloutBox ? "" : description} tooltipOptions={{ direction: "bottom" }} />
      {/if}
    </div>
  </div>
  <div class:arrayInput={parameter.type === 'array'} class="maximize">
    <TypedInput inline={parameter.type !== 'each'} types={[...allowedTypes, ...additionalEachTypes]} bind:type={parameter.type} bind:value={parameter.value} {placeholder} 
      clazz={getTypedInputClazz(parameter)}
      disabled={!parameter.isActive || nestedParam.parentActive === false || (parameter.type === 'select' && (paramMetaData.enum || paramMetaData.items?.enum || schema?.enum)?.length === 1)}
      error={required && (parameter.type !== 'array' && !parameter.type.startsWith('editor')) && parameter.value === ''}
      on:change={handleTypeSelection}
    />
  </div>
</Row>	
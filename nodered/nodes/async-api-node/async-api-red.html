<script type="text/javascript">
    RED.nodes.registerType('async-api-red', {
        category: 'network',
        color: 'rgb(136 81 251)',
        defaults: {
            name: {value: ""}
        },
        inputs: 1,
        outputs: 1,
        icon: "white-globe.svg",
        label: function () {
            return this.name || "AsyncApi-red";
        },
        oneditprepare: function () {

            const node = this;

            if (node?.id) {

                // Fetch saved file
                getFile(node.id)
                    .then(() => getUserSelections(node.id))
                    .then((res) => {
                        if (res.serverUrl && res.topic && res.operation) {
                            prefillSelections(res);
                        }
                    });

                // get the payload and update the messages
                RED.comms.subscribe(`async-api-red/payload-update/${node.id}`, function (topic, msg) {
                    if (msg && msg.payload && typeof msg.payload === "object") {
                        Object.entries(msg.payload).forEach(([key, value]) => {
                            const input = $(`#node-input-${key}`);
                            if (input.length) {
                                input.val(value);
                            }
                        });
                    }
                });

                RED.comms.subscribe(`async-api-red/payload-error/${node.id}`, function (topic, msg) {
                    RED.notify(`âŒ Validation Error: ${msg.error}`, "error");
                });

            }

            // Handle file input selection
            $("#node-input-file").on("change", (event) => {
                const file = event.target.files[0];
                if (file && node?.id) {
                    uploadFile(node.id, file);
                }
            });
        },
        oneditsave: function () {
            const node = this;
            if (node?.id) {

                const selectedServer = $("#node-input-select-server").val();
                const selectedChannelAddress = $("#node-input-channel").val();
                const selectedOperationId = $("#node-input-operations").val();


                getData(node.id).then((response) => {
                    const selectedChannel = response.channels.find(
                        ch => ch.address === selectedChannelAddress
                    );

                    const selectedOperation = selectedChannel?.operations?.find(
                        op => op.id === selectedOperationId
                    );

                    let data = {
                        serverUrl: selectedServer,
                        topic: selectedChannel.address,
                        operation: selectedOperation,
                        expectedPayload: getExpectedMessages()
                    }

                    saveUserSelections(node.id, data);
                    connectToServer(node.id).then(() => {
                        console.log('Connected to server, now creating topic...');
                        handleMessage(node.id);
                    }).catch((err) => {
                        console.error('Failed to connect to server:', err);
                    });

                    function getExpectedMessages() {
                        const messages = [];
                        selectedOperation.messages.forEach(item => {
                            item.payload.forEach(message => {
                                messages.push(message);
                            });
                        });
                        return messages;
                    }
                });
            }
            RED.comms.unsubscribe(`async-api-red/payload-error/${node.id}`);
        },
    });

    /** Function to fetch saved file */
    function getFile(nodeId) {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: `/async-api-red/${nodeId}/file`,
                type: "GET",
                success: function (response) {
                    try {
                        console.log("File loaded:", response.fileName);

                        let fileContent = response.fileContent;
                        let blob = new Blob([fileContent], {type: "text/plain"});
                        let file = new File([blob], response.fileName, {type: response.fileType});
                        let dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);

                        $("#node-input-file")[0].files = dataTransfer.files;

                        // Fetch related information
                        getData(nodeId).then((dataResponse) => {
                            updateDialogData(dataResponse);
                            resolve({file: response, data: dataResponse});
                        }).catch(err => {
                            console.error("Error fetching related data:", err);
                            reject(err);
                        });
                    } catch (e) {
                        reject(e);
                    }
                },
                error: function (err) {
                    console.error("Error fetching file:", err);
                    reject(err);
                }
            });
        });
    }


    /** Function to upload file */
    function uploadFile(nodeId, file) {

        if (!file.name.endsWith('.yaml') && !file.name.endsWith('.json')) {
            alert("Please upload a .yaml or .json AsyncAPI file.");
            return;
        }

        const formData = new FormData();
        formData.append("file", file);

        $.ajax({
            url: `/async-api-red/${nodeId}/file`,
            type: "POST",
            data: formData,
            processData: false, // Prevent jQuery from processing data
            contentType: false, // Let browser set correct Content-Type
            success: function (response) {
                console.log("File uploaded:", response);
                // Fetch updated information after file upload
                getData(nodeId).then((response) => {
                    updateDialogData(response);
                });
            },
            error: function () {
                alert("File upload failed");
            }
        });
    }

    /** Function to fetch servers */
    async function getData(nodeId) {
        return new Promise((resolve, reject) => {
            $.ajax({
                type: "GET",
                url: `/async-api-red/${nodeId}/data`,
                success: function (response) {
                    resolve(response)
                },
                error: function (err) {
                    console.error("Error fetching servers:", err);
                    reject(err);
                }
            });
        });
    }


    function saveUserSelections(nodeId, data) {
        $.ajax({
            url: `/async-api-red/${nodeId}/user-selections`,
            type: "POST",
            contentType: "application/json",
            data: JSON.stringify(data),
            success: function (response) {
            },
            error: function (err) {
            }
        });
    }

    function getUserSelections(nodeId) {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: `/async-api-red/${nodeId}/user-selections`,
                type: "GET",
                contentType: "application/json",
                success: function (response) {
                    resolve(response); // Pass the response back
                },
                error: function (err) {
                    console.error("Error fetching user selections:", err);
                    reject(err);
                }
            });
        });
    }


    function connectToServer(nodeId) {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: `/async-api-red/${nodeId}/server-connect`,
                type: "GET",
                contentType: "application/json",
                success: resolve,
                error: reject
            });
        });
    }

    /**
     *
     * @param data
     */
    function updateDialogData(data) {
        let serverDropdown = $("#node-input-select-server");
        let channelDropdown = $("#node-input-channel");
        let operationDropdown = $("#node-input-operations");

        serverDropdown.empty();
        channelDropdown.empty();
        operationDropdown.empty();

        // Populate servers
        if (data.servers) {
            data.servers.forEach(server => {
                serverDropdown.append(
                    `<option value="${server.url}">${server.url}</option>`
                );
            });
        }

        // Save channels for later use
        const channels = data.channels || [];

        // Populate channels dropdown
        channels.forEach(channel => {
            channelDropdown.append(
                `<option value="${channel.address}">${channel.address}</option>`
            );
        });

        // Bind event to load operations based on selected channel
        channelDropdown.off("change").on("change", function () {
            const selectedChannelAddress = $(this).val();
            updateOperationDropdown(operationDropdown, selectedChannelAddress, channels);
            const selectedOperationId = operationDropdown.val();
            updateMessagePanel(channels, selectedOperationId);
        });
        //  trigger change event if you want to auto-load operations for the first channel
        channelDropdown.trigger("change");

        operationDropdown.off("change").on("change", function () {
            const selectedOperationId = $(this).val();
            updateMessagePanel(channels, selectedOperationId);
        });
        operationDropdown.trigger("change");

    }

    function renderMessages(selectedChannel, selectedOperation) {
        const messages = selectedOperation.messages;

        const container = $("#node-messages-display");
        container.empty();

        if (!messages.length) {
            container.append("<div>No messages available for this operation.</div>");
            return;
        }

        messages.forEach((message, index) => {
            // Start creating HTML for each message
            let html = `
        <div style="margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">
            <strong>${index + 1}. ${message.name}</strong><br/>
            <em>Summary:</em> ${selectedOperation.summary}<br/>
            <em>Topic:</em> ${selectedChannel.address}<span style=" display: inline-block;
                                                        color: #e1f5fe;
                                                        background-color: #0277bd;
                                                        border-radius: 10px;
                                                        font-size: 11px;
                                                        font-weight: bold;
                                                        padding: 2px 8px;
                                                        margin-left: 8px;
                                                        text-transform: uppercase;">${selectedOperation.action === 'send' ? 'Publish' : 'Subscribe'}</span><br/>
            <em>Operation:</em> ${selectedOperation.id}<br/>
            <em>Content Type:</em> ${message.contentType}<br/>
        `;

            // Iterate through each property in the payload and create a form row
            if (message.payload?.length) {
                message.payload.forEach((item) => {
                    let inputHtml = '';
                    // Determine the input type based on the value's type
                    if (item.type === "integer") {
                        inputHtml = `
                    <div class="form-row" style="margin-top:.5em">
                        <label for="node-input-${item.name}"><i class="fa fa-list"></i> ${item.name}</label>
                        <input type="number" id="node-input-${item.name}"  placeholder="${item.description}">
                    </div>
                    `;
                    } else if (item.type === "string") {
                        inputHtml = `
                    <div class="form-row" style="margin-top:.5em">
                        <label for="node-input-${item.name}"><i class="fa fa-list"></i> ${item.name}</label>
                        <input type="text" id="node-input-${item.name}" " placeholder="${item.description}">
                    </div>
                    `;
                    }
                    html += inputHtml; // Add the generated input field to the HTML
                });
            }

            // Close the message div
            html += `</div>`;

            // Append the dynamically generated message HTML
            container.append(html);
        });
    }

    function updateMessagePanel(channels, selectedOperationId) {
        const selectedChannelAddress = $("#node-input-channel").val();

        const selectedChannel = channels.find(
            ch => ch.address === selectedChannelAddress
        );

        const selectedOperation = selectedChannel?.operations?.find(
            op => op.id === selectedOperationId
        );

        renderMessages(selectedChannel, selectedOperation);
    }

    function updateOperationDropdown(operationDropdown, selectedChannelAddress, channels) {
        operationDropdown.empty();

        const selectedChannel = channels.find(
            ch => ch.address === selectedChannelAddress
        );

        if (selectedChannel && selectedChannel.operations) {
            selectedChannel.operations.forEach(operation => {
                operationDropdown.append(
                    `<option value="${operation.id}">${operation.id}</option>`
                );
            });
        }
    }

    function handleMessage(nodeId, topicName) {
        $.ajax({
            url: `/async-api-red/${nodeId}/message`,
            type: "POST",
            contentType: "application/json",
            data: JSON.stringify({topic: topicName}),
            success: function (response) {
                console.log('Topic created successfully:', response.topic);
            },
            error: function (err) {
                console.error('Failed to create topic', err);
            }
        });
    }

    function prefillSelections(data) {
        // Prefill form inputs
        $("#node-input-select-server").val(data.serverUrl);
        $("#node-input-channel").val(data.topic).trigger("change");

        // Use a small timeout to ensure operations are populated first
        setTimeout(() => {
            $("#node-input-operations").val(data.operation?.id || "").trigger("change");
        }, 300);
    }


</script>

<script type="text/html" data-template-name="async-api-red">

    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>

    <div class="form-row">
        <label for="node-input-file"><i class="fa fa-file"></i>AsyncAPI File</label>
        <input type="file" id="node-input-file">
        <input type="hidden" id="node-input-fileContent"/>
    </div>

    <div class="form-row">
        <label for="node-input-select-server"><i class="fa fa-server"></i>Server</label>
        <select id="node-input-select-server"></select>
    </div>

    <div class="form-row">
        <label for="node-input-channel"><i class="fa fa-comments"></i>Topic</label>
        <select id="node-input-channel"></select>
    </div>

    <div class="form-row">
        <label><i class="fa fa-list"></i>Operations</label>
        <select id="node-input-operations"></select>
    </div>

    <div class="form-row">
        <label><i class="fa fa-envelope"></i>Message</label>
        <div id="node-messages-display"
             style="background: #f5f5f5;
             padding: 10px;
             max-height: 300px;
             overflow-y: auto;
             font-family: monospace;
             font-size: 12px;">
        </div>
    </div>


</script>

<script type="text/html" data-help-name="async-api-red">
    <p>Parse AsyncAPI descriptions to nodered-ui</p>
</script>
